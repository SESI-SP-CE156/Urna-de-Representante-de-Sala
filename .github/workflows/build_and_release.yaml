name: Build & Release

on:
  workflow_dispatch:
  push:
    branches:
      - dev
  pull_request:
    types: [closed]
    branches:
      - main

permissions:
  contents: write

jobs:
  # ===================================================
  # JOB 1: BUILD (Roda em paralelo para Linux e Windows)
  # ===================================================
  build:
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    name: Build for ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true

      # --- LINUX STEPS ---
      - name: Install Linux Dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y clang cmake ninja-build pkg-config libgtk-3-dev liblzma-dev libstdc++-12-dev libsqlite3-dev libfuse2 imagemagick

      - name: Install Project Dependencies
        run: flutter pub get

      - name: Run Build Runner
        run: dart run build_runner build --delete-conflicting-outputs

      # --- BUILD LINUX ---
      - name: Build Linux
        if: matrix.os == 'ubuntu-latest'
        run: flutter build linux --release

      - name: Create AppImage (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
          chmod +x linuxdeploy-x86_64.AppImage

          mkdir -p AppDir/usr/bin
          cp -r build/linux/x64/release/bundle/* AppDir/usr/bin/

          # Cria a pasta de libs e copia o sqlite renomeado
          mkdir -p AppDir/usr/lib
          cp /usr/lib/x86_64-linux-gnu/libsqlite3.so.0 AppDir/usr/lib/libsqlite3.so

          # Padronizar nome do execut치vel
          if [ -f "AppDir/usr/bin/Urna" ]; then
            mv AppDir/usr/bin/Urna AppDir/usr/bin/urna
          fi

          cat > urna.desktop <<EOF
          [Desktop Entry]
          Name=Urna Eletr칪nica
          Exec=urna
          Icon=urna
          Type=Application
          Categories=Utility;
          EOF

          if [ -f "linux/runner/resources/application_icon.png" ]; then
            cp linux/runner/resources/application_icon.png urna.png
          else
            wget -q -O urna.png https://storage.googleapis.com/cms-storage-bucket/0dbfcc7a59cd1cf16282.png
          fi

          # Redimensionar 칤cone
          convert urna.png -resize 256x256! urna.png

          ./linuxdeploy-x86_64.AppImage \
            --appdir AppDir \
            --executable AppDir/usr/bin/urna \
            --desktop-file urna.desktop \
            --icon-file urna.png \
            --output appimage

          mv Urna_Eletr칪nica*.AppImage urna-linux-x64.AppImage

      # --- UPLOAD LINUX ARTIFACT ---
      # Em vez de criar release, salvamos o arquivo para o pr칩ximo job
      - name: Upload Linux Artifact
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: linux-build
          path: urna-linux-x64.AppImage
          compression-level: 0 # J치 est치 comprimido

      # --- BUILD WINDOWS ---
      - name: Build Windows
        if: matrix.os == 'windows-latest'
        run: flutter build windows --release

      - name: Sign Windows Executable
        if: matrix.os == 'windows-latest'
        shell: powershell
        env:
          PFX_BASE64: ${{ secrets.WINDOWS_PFX_BASE64 }}
          PFX_PASSWORD: ${{ secrets.WINDOWS_PFX_PASSWORD }}
        run: |
          $pfx_bytes = [System.Convert]::FromBase64String($env:PFX_BASE64)
          [IO.File]::WriteAllBytes("certificate.pfx", $pfx_bytes)

          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "signtool.exe" | Sort-Object FullName -Descending | Select-Object -First 1

          if (-not $signtool) { Write-Error "Signtool not found!"; exit 1 }

          $exePath = "build\windows\x64\runner\Release\urna.exe"
          & $signtool.FullName sign /f "certificate.pfx" /p $env:PFX_PASSWORD /tr http://timestamp.digicert.com /td sha256 /fd sha256 $exePath

          Remove-Item "certificate.pfx"

      - name: Compress Windows Build
        if: matrix.os == 'windows-latest'
        run: |
          Compress-Archive -Path build\windows\x64\runner\Release\* -DestinationPath urna-windows-x64.zip

      # --- UPLOAD WINDOWS ARTIFACT ---
      - name: Upload Windows Artifact
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: urna-windows-x64.zip
          compression-level: 0

  # ===================================================
  # JOB 2: RELEASE (Roda AP칍S os builds terminarem)
  # ===================================================
  release:
    needs: build # Aguarda o job 'build' terminar (ambos OS)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 1. Baixa TODOS os artefatos gerados no job anterior
      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: "*-build" # Baixa linux-build e windows-build
          merge-multiple: true # Coloca todos os arquivos na raiz da pasta

      # 2. Gera a Descri칞칚o e Tag baseada no evento
      - name: Generate Release Details
        id: details
        run: |
          # Define Tag e Nome
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "release_tag=v0.1.0-${{ github.run_number }}" >> $GITHUB_OUTPUT
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "release_name=Release v0.1.0 (Build ${{ github.run_number }})" >> $GITHUB_OUTPUT
          else
            echo "release_tag=dev-build-${{ github.run_number }}" >> $GITHUB_OUTPUT
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "release_name=Development Build ${{ github.run_number }}" >> $GITHUB_OUTPUT
          fi

          # Gera o Corpo da Release (Descri칞칚o) em um arquivo
          echo "### 游닍 Detalhes da Vers칚o" > release_body.md
          echo "" >> release_body.md

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "游 **Origem: Pull Request #${{ github.event.pull_request.number }}**" >> release_body.md
            echo "**T칤tulo:** ${{ github.event.pull_request.title }}" >> release_body.md
            echo "" >> release_body.md
            echo "游닇 **Descri칞칚o do PR:**" >> release_body.md
            echo "${{ github.event.pull_request.body }}" >> release_body.md
          else
            echo "游 **Origem: Commit na Branch ${{ github.ref_name }}**" >> release_body.md
            echo "**Commit Hash:** ${{ github.sha }}" >> release_body.md
            echo "" >> release_body.md
            echo "游닇 **Mensagem do Commit:**" >> release_body.md
            echo "${{ github.event.head_commit.message }}" >> release_body.md
          fi

      # 3. Publica a Release 칔nica com os arquivos
      - name: Publish Release
        uses: ncipollo/release-action@v1
        with:
          allowUpdates: true
          removeArtifacts: true
          replacesArtifacts: true
          tag: ${{ steps.details.outputs.release_tag }}
          name: ${{ steps.details.outputs.release_name }}
          bodyFile: release_body.md
          prerelease: ${{ steps.details.outputs.is_prerelease }}
          artifacts: "urna-linux-x64.AppImage,urna-windows-x64.zip"
          token: ${{ secrets.GITHUB_TOKEN }}
